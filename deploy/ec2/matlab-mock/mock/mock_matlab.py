#!/usr/bin/env python3
"""
Mock MATLAB simulator for demo pipeline.

Parses the -batch command string and fakes the appropriate operation:
  - test_<algo>: reads test vectors, writes matlab_outputs.json using expected values
  - codegen_config: writes pre-built C++ to the generated directory

Supports all algorithms: kalman_filter, low_pass_filter, pid_controller
"""

import json
import os
import re
import sys
import glob


def handle_test(batch_code):
    """Fake MATLAB test harness: read test vectors, write matlab_outputs.json.

    Works generically for any algorithm — reads expected_output keys and
    writes them as actual_<key> entries in the output.
    """
    # Parse: results = test_<algo>('vectors_dir', 'results_dir');
    m = re.search(r"test_\w+\(\s*'([^']+)'\s*,\s*'([^']+)'\s*\)", batch_code)
    if not m:
        print("Mock MATLAB: could not parse test command", file=sys.stderr)
        return 1

    vectors_dir = m.group(1)
    results_dir = m.group(2)

    print(f"Mock MATLAB: running test harness")
    print(f"  Vectors dir: {vectors_dir}")
    print(f"  Results dir: {results_dir}")

    os.makedirs(results_dir, exist_ok=True)

    outputs = []
    total = 0
    for vector_file in sorted(glob.glob(os.path.join(vectors_dir, "*.json"))):
        if "schema" in os.path.basename(vector_file):
            continue
        with open(vector_file) as f:
            data = json.load(f)

        global_tol = 1e-10
        if "global_tolerance" in data and "absolute" in data["global_tolerance"]:
            global_tol = data["global_tolerance"]["absolute"]

        for tc in data.get("test_cases", []):
            total += 1
            name = tc["name"]
            expected = tc["expected_output"]

            # Use expected output as "actual" (mock produces perfect results)
            tol = global_tol
            if "tolerance" in tc and "absolute" in tc["tolerance"]:
                tol = tc["tolerance"]["absolute"]

            # Generic: copy all expected_output fields as actual_<key>
            entry = {"test_name": name, "tolerance": tol}
            for key, value in expected.items():
                entry[f"actual_{key}"] = value

            outputs.append(entry)
            print(f"  PASS: {name}")

    # Write matlab_outputs.json
    output_path = os.path.join(results_dir, "matlab_outputs.json")
    with open(output_path, "w") as f:
        json.dump(outputs, f, indent=2)

    print(f"MATLAB tests PASSED: {total} of {total}")
    return 0


def handle_codegen(batch_code):
    """Fake MATLAB Coder: write pre-built C++ to the generated directory."""
    # Parse: codegen_config('gen_dir');
    m = re.search(r"codegen_config\(\s*'([^']+)'\s*\)", batch_code)
    if not m:
        print("Mock MATLAB: could not parse codegen command", file=sys.stderr)
        return 1

    gen_dir = m.group(1)

    # Detect algorithm name from batch code
    # The batch code contains: fprintf('Code generation succeeded for <algo>\n');
    algo_m = re.search(r"succeeded for (\w+)", batch_code)
    algo = algo_m.group(1) if algo_m else None

    # Also try to detect from the gen_dir path (e.g., /path/algorithms/kalman_filter/generated)
    if not algo:
        path_m = re.search(r"algorithms/(\w+)/generated", gen_dir)
        algo = path_m.group(1) if path_m else "unknown"

    print(f"Mock MATLAB: running code generation for {algo}")
    print(f"  Output dir: {gen_dir}")

    if algo not in ALGO_TEMPLATES:
        print(f"Mock MATLAB: no templates for algorithm '{algo}'", file=sys.stderr)
        return 1

    os.makedirs(gen_dir, exist_ok=True)

    templates = ALGO_TEMPLATES[algo]
    for filename, content in templates.items():
        filepath = os.path.join(gen_dir, filename)
        with open(filepath, "w") as f:
            f.write(content)
        print(f"  Generated: {filename}")

    print(f"Code generation succeeded for {algo}")
    return 0


# ---------------------------------------------------------------------------
# Embedded C++ templates for each algorithm
# ---------------------------------------------------------------------------

KALMAN_FILTER_H = r"""#ifndef KALMAN_FILTER_H
#define KALMAN_FILTER_H

// Auto-generated by MATLAB Coder (mock)

namespace kalman_filter {

void kalman_filter(
    const double state[2],
    double measurement,
    const double state_covariance[4],
    double measurement_noise,
    double process_noise,
    double updated_state[2],
    double updated_covariance[4]);

} // namespace kalman_filter

#endif // KALMAN_FILTER_H
"""

KALMAN_FILTER_CPP = r"""#include "kalman_filter.h"

namespace kalman_filter {

void kalman_filter(
    const double state[2],
    double measurement,
    const double state_covariance[4],
    double measurement_noise,
    double process_noise,
    double updated_state[2],
    double updated_covariance[4])
{
    double P11 = state_covariance[0];
    double P12 = state_covariance[1];
    double P21 = state_covariance[2];
    double P22 = state_covariance[3];

    // --- Predict (constant velocity, dt=1) ---
    double x_pred0 = state[0] + state[1];
    double x_pred1 = state[1];

    double Pp11 = (P11 + P21) + (P12 + P22) + process_noise;
    double Pp12 = (P12 + P22);
    double Pp21 = (P21 + P22);
    double Pp22 = P22 + process_noise;

    // --- Update ---
    double y = measurement - x_pred0;
    double S = Pp11 + measurement_noise;

    double K0 = Pp11 / S;
    double K1 = Pp21 / S;

    updated_state[0] = x_pred0 + K0 * y;
    updated_state[1] = x_pred1 + K1 * y;

    // Joseph form covariance update
    double ikh00 = 1.0 - K0;
    double ikh10 = -K1;

    double A00 = ikh00 * Pp11;
    double A01 = ikh00 * Pp12;
    double A10 = ikh10 * Pp11 + Pp21;
    double A11 = ikh10 * Pp12 + Pp22;

    double P_up11 = A00 * ikh00;
    double P_up12 = A00 * ikh10 + A01;
    double P_up21 = A10 * ikh00;
    double P_up22 = A10 * ikh10 + A11;

    P_up11 += K0 * measurement_noise * K0;
    P_up12 += K0 * measurement_noise * K1;
    P_up21 += K1 * measurement_noise * K0;
    P_up22 += K1 * measurement_noise * K1;

    updated_covariance[0] = P_up11;
    updated_covariance[1] = P_up12;
    updated_covariance[2] = P_up21;
    updated_covariance[3] = P_up22;
}

} // namespace kalman_filter
"""

LOW_PASS_FILTER_H = r"""#ifndef LOW_PASS_FILTER_H
#define LOW_PASS_FILTER_H

// Auto-generated by MATLAB Coder (mock)

namespace low_pass_filter {

void low_pass_filter(
    const double input_signal[],
    double alpha,
    int n,
    double output_signal[]);

} // namespace low_pass_filter

#endif // LOW_PASS_FILTER_H
"""

LOW_PASS_FILTER_CPP = r"""#include "low_pass_filter.h"

namespace low_pass_filter {

void low_pass_filter(
    const double input_signal[],
    double alpha,
    int n,
    double output_signal[])
{
    if (n <= 0) return;

    output_signal[0] = input_signal[0];

    for (int k = 1; k < n; k++) {
        output_signal[k] = alpha * input_signal[k] + (1.0 - alpha) * output_signal[k - 1];
    }
}

} // namespace low_pass_filter
"""

PID_CONTROLLER_H = r"""#ifndef PID_CONTROLLER_H
#define PID_CONTROLLER_H

// Auto-generated by MATLAB Coder (mock)

namespace pid_controller {

void pid_controller(
    double error,
    double integral,
    double prev_error,
    double kp,
    double ki,
    double kd,
    double dt,
    double* output,
    double* new_integral,
    double* new_prev_error);

} // namespace pid_controller

#endif // PID_CONTROLLER_H
"""

PID_CONTROLLER_CPP = r"""#include "pid_controller.h"

namespace pid_controller {

void pid_controller(
    double error,
    double integral,
    double prev_error,
    double kp,
    double ki,
    double kd,
    double dt,
    double* output,
    double* new_integral,
    double* new_prev_error)
{
    // Update integral
    *new_integral = integral + error * dt;

    // Derivative term
    double derivative = (error - prev_error) / dt;

    // PID output
    *output = kp * error + ki * (*new_integral) + kd * derivative;

    // Store current error for next step
    *new_prev_error = error;
}

} // namespace pid_controller
"""

# Algorithm name -> {filename: content} mapping
ALGO_TEMPLATES = {
    "kalman_filter": {
        "kalman_filter.h": KALMAN_FILTER_H,
        "kalman_filter.cpp": KALMAN_FILTER_CPP,
    },
    "low_pass_filter": {
        "low_pass_filter.h": LOW_PASS_FILTER_H,
        "low_pass_filter.cpp": LOW_PASS_FILTER_CPP,
    },
    "pid_controller": {
        "pid_controller.h": PID_CONTROLLER_H,
        "pid_controller.cpp": PID_CONTROLLER_CPP,
    },
}


# ---------------------------------------------------------------------------
# Main entry point
# ---------------------------------------------------------------------------

def main():
    if len(sys.argv) < 2:
        print("Mock MATLAB: no batch code provided", file=sys.stderr)
        sys.exit(1)

    batch_code = sys.argv[1]

    if "test_" in batch_code:
        sys.exit(handle_test(batch_code))
    elif "codegen_config" in batch_code:
        sys.exit(handle_codegen(batch_code))
    else:
        # Unknown command — just succeed silently
        print(f"Mock MATLAB: unrecognized command, returning success")
        sys.exit(0)


if __name__ == "__main__":
    main()
